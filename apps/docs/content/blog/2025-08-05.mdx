---
title: Atualiza√ß√£o 1.4.0 - Modulariza√ß√£o de comandos
tags: [cli, updates, feats]
description: Divida seus comandos gigantes em arquivos diferentes e com seguran√ßa de tipo
---
import icons from "@lib/icons";
import { CliCommand } from "@/components/constatic/cli/command";

Finalmente uma solu√ß√£o elegante e segura para o problema do c√≥digo gigante quando comandos com grupos e sub comandos eram criados. A base tamb√©m foi simplificada para que as pr√≥ximas atualiza√ß√µes sejam mais pr√°ticas...

Comando para executar a CLI

<CliCommand packageName="constatic@latest" />

# Remo√ß√µes

A pasta `./src/settings/` n√£o existe mais! Abaixo est√° uma lista de todos os arquivos que ela abrigava e pra onde eles foram agora:

## env.schema.ts

Esse era o arquivo onde voc√™ podia definir o _**schema zod**_ das suas vari√°veis de ambiente. 
<Accordions>
    <Accordion title="Veja como era:">
    ```ts title="src/settings/env.schema.ts"
    import { z } from "zod";

    export const envSchema = z.object({
        BOT_TOKEN: z.string("Discord Bot Token is required").min(1),
        WEBHOOK_LOGS_URL: z.url().optional()
    });
    ```
    </Accordion>
</Accordions>

Agora isso foi simplificado, voc√™ ter√° um arquivo `./src/env.ts` (no workdir mesmo) para definir o _**schema**_ das suas vari√°veis de ambiente e j√° exportando o objeto `env` validado e transformado:

```ts title="./src/env.ts"
import { validateEnv } from "#base";
import { z } from "zod";
// [!code word:env]

export const env = validateEnv(z.object({
    BOT_TOKEN: z.string("Discord Bot Token is required").min(1),
    WEBHOOK_LOGS_URL: z.url().optional()
}));
```

## env.validate.ts

Esse arquivo declarava a fun√ß√£o `validateEnv` e era importada nos arquivos de `./src/discord/base/`. Mas agora essa fun√ß√£o foi movida para `./src/discord/base/` de vez.
Ela √© importada no arquivo `./src/env.ts` para validar e transformar o `process.env`:

```ts title="./src/env.ts"
// [!code word:validateEnv]
import { validateEnv } from "#base"; // [!code highlight]
// ...
```

## logger.ts

Este arquivo exportava um objeto simples com m√©todos de log no terminal. Foi movido tamb√©m para a pasta `./src/discord/base`.

Futuramente receber√° novidades...

## error.ts

Declarava uma fun√ß√£o para lidar com erros inesperados (famoso anti-crash, por√©m feito do jeito certo). Tamb√©m movido para `./src/discord/base`. 

## global.ts

Neste arquivo eram declaradas algumas variaveis globais tipagens espec√≠ficas, mas agora foi deletado para sempre!

## Objeto settings

Agora um dos mais importantes aqui, que o arquivo index.ts importava o arquivo `settings.json` da raiz do projeto e exportava dessa pasta, para que pudesse ser importado de qualquer lugar facilmente usando o atalho de importa√ß√£o `#settings`. Sem isso voc√™ precisaria importar o arquivo json usando caminhos relativos e o atributo de importa√ß√£o toda vez: `import settings from "../../../../settings.json" with { type: "json" }`.

Depois de pensar bastante chegamos a uma conclus√£o. Faz mais sentido o arquivo se chamar `constants.json`, pois armazena informa√ß√µes est√°ticas que n√£o ser√£o alteradas em nenhum momento em tempo de execu√ß√£o!

```properties title="./"
  settings.json # [!code --]
  constants.json # [!code ++]
```

E ele estar√° dispon√≠vel globalmente com seguran√ßa de tipos! N√£o √© necess√°rio importar de nenhum lugar.

```ts
import { createCommand } from "#base";
import { createContainer } from "@magicyan/discord";
import { ApplicationCommandType } from "discord.js";
import { settings } from "#settings"; // [!code --]
// [!code word:constants]

createCommand({
  name: "ping",
  description: "Responde com pong üèì",
  type: ApplicationCommandType.ChatInput,
  async run(interaction){
    const container = createContainer({
      accentColor: settings.colors.success, // [!code --] 
      accentColor: constants.colors.success, // [!code ++] 
      components: ["Pong üèì"]
    })
    await interaction.reply({
      flags: ["Ephemeral", "IsComponentsV2"],
      components: [container]
    });
  }
});
```

---

# Fun√ß√£o bootstrapp

Algumas propriedades da fun√ß√£o bootstrapp foram alteradas e outras removidas.

## modules

A propriedade `directories` foi renomeada para `modules`, agora ao inv√©s de especificar apenas nomes de pastas, voc√™ pode definir padr√µes glob:

```ts
import { bootstrap } from "#base";

await bootstrap({ 
    meta: import.meta 
    directores: ["mycommands", "custom/myevents"], // [!code --]
    modules: ["./**/*.mod.{ts,js}", "./mycommands/**"] // [!code ++]
});
```

<Callout type="danger">
    Mas um aviso importante sobre essa op√ß√£o! Tome cuidado para n√£o especificar um padr√£o que importe tudo do workdir (o diret√≥rio de trabalho atual, em desenvolvimento √© a pasta src, e em produ√ß√£o √© a pasta build) ou da pasta `src/discord/base`. Isso ir√° causar depend√™ncias circulares e por consequ√™ncia, crashando o projeto.
    Ent√£o evite algo como isso:

    ```ts title="src/index.ts"
    await bootstrap({ 
        meta: import.meta,
        modules: [
            "./discord/base/**", // [!code --]
            "./**/*", // [!code --]
            "./", // [!code --]
            "." // [!code --]
        ]
    });
    ```
</Callout>

## whenReady

Se voc√™ usava essa op√ß√£o antes para executar algum c√≥digo no pr√≥prio `ready` da base, precisar√° alterar o seu c√≥digo para usar `createEvent` em favor das mudan√ßas ditas logo abaixo:

## Eventos

A forma com que os eventos s√£o registrados e executados foi alterada internamente. 

- Eventos marcados como `once` s√£o deletados da collection de eventos depois de serem executados (faz sentido pois eles s√≥ ser√£o executados uma √∫nica vez mesmo).
- Qualquer evento `ready` √© automaticamente definido como `once`, pois s√≥ ser√° executado uma vez quando o bot iniciar.
- Todos os eventos `ready` ser√£o executados apenas depois das execu√ß√µes do evento `ready` da base (que inclui o registro dos comandos).

# Autocomplete

Agora voc√™ pode definir uma fun√ß√£o autocomplete diretamente na defini√ß√£o da op√ß√£o! Isso significa que se voc√™ tiver muitos grupos e sub comandos, n√£o precisa mais usar v√°rios cases em switchs para descobrir qual op√ß√£o autocomplete est√° sendo emitida.

Vamos ver um exemplo simples:

```ts title="mycommand.ts"
import { createCommand } from "#base";
import { ytclient } from "#mylib";
import { ApplicationCommandOptionType } from "discord.js";

createCommand({
    name: "pesquisar",
    description: "Comando de pesquisa",
    options: [
       {
          name: "video",
          description: "Digite algo para pesquisar",
          type: ApplicationCommandOptionType.String,
          autocomplete: true // [!code highlight]
       }
    ],
    async autocomplete({ options }){ // [!code highlight]
        const query = options.getFocused(); // [!code highlight]

        const results = await ytclient // [!code highlight]
            .search(query, "videos"); // [!code highlight]

        return results.map(video => ({ // [!code highlight]
            name: `${video.channel.name} | ${video.title}`, // [!code highlight]
            value: video.id // [!code highlight]
        })); // [!code highlight]
    }, // [!code highlight]
    async run(interaction){

        const videoId = interaction.options.getString("video");
        
        // ...
    }
});
```

Acima respondemos uma √∫nica op√ß√£o autocomplete usando a fun√ß√£o `autocomplete` no objeto inteiro do comando. Mas agora podemos colocar essa fun√ß√£o diretamente na op√ß√£o:

```ts title="mycommand.ts"
import { createCommand } from "#base";
import { ytclient } from "#mylib";
import { ApplicationCommandOptionType } from "discord.js";

createCommand({
    name: "pesquisar",
    description: "Comando de pesquisa",
    options: [
       {
          name: "video",
          description: "Digite algo para pesquisar",
          type: ApplicationCommandOptionType.String,
          autocomplete: true, // [!code --]
          async autocomplete({ options }){ // [!code ++]
            const query = options.getFocused(); // [!code ++]

            const results = await ytclient // [!code ++]
                .search(query, "videos"); // [!code ++]

            return results.map(video => ({ // [!code ++]
                name: `${video.channel.name} | ${video.title}`, // [!code ++]
                value: video.id // [!code ++]
            })); // [!code ++]
        }, // [!code ++]
       }
    ],
    async autocomplete({ options }){ /* ... */} // [!code --]
    async run(interaction){

        const videoId = interaction.options.getString("video");
        
        // ...
    }
});
```

Vendo um exemplo com uma √∫nica op√ß√£o, n√£o parece ser um recurso t√£o √∫til. Mas considere essa situa√ß√£o:

Voc√™ criou um comando com v√°rios grupos e sub comandos e muitos deles tem op√ß√µes autocomplete, o seu handler ficaria parecido com isso:

```ts title="mycommand.ts"
import { createCommand } from "#base";
import { ApplicationCommandOptionType } from "discord.js";

createCommand({
    name: "supercommand",
    description: "Super comando",
    options: [
       {/* ... */},
       {/* ... */},
       {/* ... */},
       {/* ... */},
       {/* ... */},
    ],
    async autocomplete({ options }){
      const group = options.getSubcommandGroup();
      const subcommand = options.getSubcommand();

      switch(group){
        case "a":{
          switch(subcommand){
            case "foo": {
              // ...
            }
            case "bar": {
              // ...
            }
            case "baz": {
              // ...
            }
          }
          return;
        }
        case "b":{
          switch(subcommand){
            case "foo": {
              // ...
            }
            case "bar": {
              // ...
            }
            case "baz": {
              // ...
            }
          }
          return;
        }
        case "c":{
          switch(subcommand){
            case "foo": {
              // ...
            }
            case "bar": {
              // ...
            }
            case "baz": {
              // ...
            }
          }
          return;
        }
        case "d": //...
        case "e": //...
        // ...
      }
    },
    async run(interaction){
      const group = options.getSubcommandGroup();
      const subcommand = options.getSubcommand();

      switch(group){
        case "a": // ...
        // ...
        // ...
        // ...
        // ...
        // ...
      }
    }
});
```

Podendo definir a fun√ß√£o `autocomplete` diretamente na op√ß√£o, n√£o √© necess√°rio verificar qual grupo e sub comando ela pertence, o handler da base far√° isso pra voc√™!

```ts title="mycommand.ts"
import { createCommand } from "#base";
import { ytclient } from "#mylib";
import { ApplicationCommandOptionType } from "discord.js";

createCommand({
    name: "gerenciar",
    description: "Comando de gerenciamento",
    options: [
       {
          name: "ranks",
          description: "Gerencie os ranks do servidor",
          type: ApplicationCommandOptionType.Subcommand,
          options: [
            {
              name: "rank",
              description: "Selecione o rank que deseja",
              type: ApplicationCommandOptionType.String,
              async autocomplete({ options }){
                //...
              }
            }
          ]
       },
       {
          name: "paineis",
          description: "Gerencie os paineis do servidor",
          type: ApplicationCommandOptionType.Subcommand,
          options: [
            {
              name: "painel",
              description: "Selecione o painel que deseja",
              type: ApplicationCommandOptionType.String,
              async autocomplete({ options }){
                //...
              }
            }
          ]
       },
       {
          name: "webhooks",
          description: "Gerencie os webhooks do bot",
          type: ApplicationCommandOptionType.Subcommand,
          options: [
            {
              name: "webhook",
              description: "Selecione o webhook criado pelo bot",
              type: ApplicationCommandOptionType.String,
              async autocomplete({ options }){bun
                //...
              }
            }
          ]
       }
    ],
    // ...
});
```

# Modulariza√ß√£o de comandos

Agora voc√™ pode separar os grupos e sub comandos em arquivos diferentes, com tipagem segura e inferida automaticamente! Imagine um comando gigante como este:

```ts
import { createCommand } from "#base";
import { ApplicationCommandOptionType, ApplicationCommandType } from "discord.js";

createCommand({
    name: "gerenciar",
    description: "Comando de gerenciamento",
    type: ApplicationCommandType.ChatInput,
    options: [
        {
            name: "cargos",
            description: "Gerenciar cargos",
            type: ApplicationCommandOptionType.SubcommandGroup,
            options: [
                {
                    name: "criar",
                    description: "Criar um novo cargo",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
                {
                    name: "editar",
                    description: "Editar um cargo",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
                {
                    name: "permiss√µes",
                    description: "Alterar permiss√µes de um cargo",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
                {
                    name: "deletar",
                    description: "Deletar um cargo",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
                {
                    name: "atribuir",
                    description: "Atribuir um cargo a um membro",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
            ]
        },
        {
            name: "canais",
            description: "Gerenciar canais",
            type: ApplicationCommandOptionType.SubcommandGroup,
            options: [
                {
                    name: "criar",
                    description: "Criar um novo canal",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
                {
                    name: "editar",
                    description: "Editar um canal",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
                {
                    name: "permiss√µes",
                    description: "Alterar permiss√µes de um canal",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
                {
                    name: "deletar",
                    description: "Deletar um canal",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
                {
                    name: "mover",
                    description: "Mover um canal de categoria",
                    type: ApplicationCommandOptionType.Subcommand,
                    options: [
                        // ...
                    ]
                },
            ]
        }
    ],
    async run(interaction) {
        const { options } = interaction;

        const group = options.getSubcommandGroup();
        const subcommand = options.getSubcommand();

        switch (group) {
            case "cargos": {

                switch (subcommand) {
                    case "criar": {
                        // ... +20 linhas de c√≥digo 
                        return;
                    }
                    case "editar": {
                        // ... +16 linhas de c√≥digo 
                        return;
                    }
                    case "permiss√µes": {
                        // ... +18 linhas de c√≥digo 
                        return;
                    }
                    case "deletar": {
                        // ... +10 linhas de c√≥digo 
                        return;
                    }
                    case "atribuir": {
                        // ... +22 linhas de c√≥digo 
                        return;
                    }
                }

                return;
            }
            case "canais": {
                switch (subcommand) {
                    case "criar": {
                        // ... +34 linhas de c√≥digo 
                        return;
                    }
                    case "editar": {
                        // ... +28 linhas de c√≥digo
                        return;
                    }
                    case "permiss√µes": {
                        // ... +45 linhas de c√≥digo
                        return;
                    }
                    case "deletar": {
                        // ... +25 linhas de c√≥digo
                        return;
                    }
                    case "mover": {
                        // ... +21 linhas de c√≥digo
                        return;
                    }
                }
                return;
            }
        }
    }
});
```

Para resumir, no servidor voc√™ veria os comandos assim:

- /gerenciar cargos criar
- /gerenciar cargos editar
- /gerenciar cargos permiss√µes
- /gerenciar cargos deletar
- /gerenciar cargos atribuir
- /gerenciar canais criar
- /gerenciar canais editar
- /gerenciar canais permiss√µes
- /gerenciar canais deletar
- /gerenciar canais mover

Mas no c√≥digo... Um √∫nico arquivo poderia ultrapassar 1000 linhas de c√≥digo s√≥ pra definir v√°rios sub comandos. Agora com esse novo recurso, voc√™ pode dividir o c√≥digo dos seus sub comandos em arquivos diferentes, com seguran√ßa de tipo.

Para come√ßar crie uma pasta exclusiva para o seu comando e crie um arquivo chamado `command.ts` nela:

```json
  src/
  ‚îú‚îÄ‚îÄ discord/
  ‚îÇ   ‚îî‚îÄ‚îÄ commands/
  ‚îÇ       ‚îú‚îÄ‚îÄ manage/ // [!code highlight]
  ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ command.ts // [!code highlight]
  ‚îÇ       ‚îú‚îÄ‚îÄ ping.ts
  ‚îÇ       ‚îî‚îÄ‚îÄ counter.ts
  ‚îú‚îÄ‚îÄ functions/ ...
  ‚îî‚îÄ‚îÄ index.ts
```

Neste arquivo `command.ts` declare o seu comando e j√° exportando como padr√£o:

```ts title="command.ts"
import { createCommand } from "#base";
import { ApplicationCommandType } from "discord.js";

export default createCommand({
    name: "gerenciar",
    description: "Comando de gerenciamento",
    type: ApplicationCommandType.ChatInput,
    defaultMemberPermissions: ["Administrator"]
});
```

<Callout type="info">
  A partir daqui, os exemplos s√£o relativos a pasta de comandos
</Callout>

Crie pastas para cada grupo e o arquivo `group.ts` em cada pasta:

```json
commands/
 ‚îú‚îÄ‚îÄ manage/ 
 ‚îÇ   ‚îú‚îÄ‚îÄ channels/ // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ group.ts // [!code highlight]
 ‚îÇ   ‚îú‚îÄ‚îÄ roles/ // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ group.ts // [!code highlight]
 ‚îÇ   ‚îî‚îÄ‚îÄ command.ts
 ‚îú‚îÄ‚îÄ ping.ts
 ‚îî‚îÄ‚îÄ counter.ts
```

Ent√£o em cada arquivo de grupo, importe o comando exportado em `command.ts` e use o m√©todo `.group()` para declarar que o seu comando tem um grupo e j√° exportando isso tamb√©m:

```ts tab="Cargos" title="roles/group.ts"
import command from "../command.js";

export default command.group({
    name: "cargos",
    description: "Gerenciar cargos",
});
```
```ts tab="Canais" title="channels/group.ts"
import command from "../command.js";

export default command.group({
    name: "canais",
    description: "Gerenciar canais",
});
```

Ent√£o agora basta criar um arquivo para cada sub comando do grupo em suas respectivas pastas:

```json
commands/
 ‚îú‚îÄ‚îÄ manage/ 
 ‚îÇ   ‚îú‚îÄ‚îÄ channels/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ permissions.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delete.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ move.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ group.ts
 ‚îÇ   ‚îú‚îÄ‚îÄ roles/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ edit.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ permissions.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delete.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assign.ts // [!code highlight]
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ group.ts
 ‚îÇ   ‚îî‚îÄ‚îÄ command.ts
 ‚îú‚îÄ‚îÄ ping.ts
 ‚îî‚îÄ‚îÄ counter.ts
```

Em cada arquivo voc√™ pode importar o grupo do arquivo `group.ts` e definir o sub comando e sua execu√ß√£o:

```ts title="channels/create.ts"
import group from "./group.js";
import { ApplicationCommandOptionType } from "discord.js";

export default group.subcommand({
    name: "criar",
    description: "Criar um novo canal",
    options: [
      {
        name: "nome",
        description: "Nome do canal",
        type: ApplicationCommandOptionType.String,
        required: true
      }
    ],
    async run(interaction){
      const { options } = interaction;

      const name = options.getString("nome", true);

      // ...
    }
});
```

Acima temos o exemplo de apenas um sub comando, que √© o `/gerenciar canais criar`, mas voc√™ pode criar para todos os outros, apenas seguindo a mesma l√≥gica desse!

## Utilidade real

<Callout type="warn">
  Para os mais cr√≠ticos que v√£o dizer que j√° faziam algo assim antes por√©m usando fun√ß√µes, saibam de uma coisa: Este projeto √© focado em tipagem inferida! Isso significa que as estruturas como `createCommand`, `createResponder` e `createEvent`, s√£o usadas para que voc√™ utilizador, n√£o precise ficar escrevendo tipagens o tempo todo.

  E este recurso de modulariza√ß√£o infere a tipagem do seu comando automaticamente conforme as op√ß√µes que voc√™ definiu nele! 
</Callout>

Se antes voc√™ fazia algo como isso:

```ts title="create.ts"
export async function channelCreateSubcommand(
  interaction: ChatInputCommandInteraction<"cached">
){
  // ...
}
```

E no seu comando:

```ts
import { createCommand } from "#base";
import { ApplicationCommandOptionType, ApplicationCommandType } from "discord.js";

import { channelCreateSubcommand } from "./create.js";
import { channelEditSubcommand } from "./edit.js";
import { channelDeleteSubcommand } from "./delete.js";
// ...

createCommand({
    name: "canais",
    description: "Gerenciar canais",
    type: ApplicationCommandType.ChatInput,
    options: [
        {
            name: "criar",
            type: ApplicationCommandOptionType.Subcommand,
            // ...
        },
        {
            name: "editar",
            type: ApplicationCommandOptionType.Subcommand,
            // ...
        },
        // ...
    ],
    async run(interaction) {
        const { options } = interaction;
        const subcommand = options.getSubcommand();

        switch (subcommand) {
            case "criar":{
                channelCreateSubcommand(interaction);
                return;
            }
            case "editar":{
                channelEditSubcommand(interaction);
                return;
            }
            case "deletar":{
                channelDeleteSubcommand(interaction);
                return;
            }
            // ...
        }
    }
});
```

O seu c√≥digo ainda podia ficar grande e desorganizado, mas com esse novo recurso a tipagem √© inferida automaticamente.

Ao definir `dmPermission` como `true`, o tipo da intera√ß√£o automaticamente:

```ts
// ./command.ts
export default createCommand({
    name: "gerenciar",
    description: "Comando de gerenciamento",
    type: ApplicationCommandType.ChatInput,
    dmPermission: true // [!code ++]
});

// ./channels/create.ts
export default group.subcommand({
    name: "criar",
    description: "Criar um novo canal",
    options: [
      // ..
    ],
    async run(interaction){
      interaction.guild // "Provavelmente null" // [!code highlight]
      interaction.member // "Provavelmente null" // [!code highlight]
      // ...
    }
});
```

Isso se reflete na fun√ß√£o autocomplete das op√ß√µes:

```ts
// ./channels/create.ts
export default group.subcommand({
    name: "criar",
    description: "Criar um novo canal",
    options: [
      // ...
      {
        name: "rank",
        description: "Vincular um rank a este canal",
        async autocomplete(interaction){
          interaction.guild // "Provavelmente null" // [!code highlight]
          interaction.member // "Provavelmente null" // [!code highlight]
          // ...
        }
      }
    ],
    async run(interaction){
      interaction.guild // "Provavelmente null" // [!code highlight]
      interaction.member // "Provavelmente null" // [!code highlight]
      // ...
    }
});
```

## Transporte de dados

Outra coisa que foi pensado pra esse recurso tamb√©m √© o transporte de dados. Antes usando as estruturas condicionais como **switch**, pod√≠amos obter dados uma √∫nica vez que seriam usados em v√°rios sub comandos. Considere esse exemplo:

```ts
createCommand({
  // ...
  async run(interaction) {
    const { options, guild } = interaction;

    const group = options.getSubcommandGroup();
    const subcommand = options.getSubcommand();

    switch (group) {
      case "cargos": {
        const rolesDocument = await db.roles.get(guild.id); // [!code ++]
        switch (subcommand) {
            case "criar": {
                // ... 
                rolesDocument.set(/* .. */) // [!code highlight]
                await rolesDocument.save() // [!code highlight]
                return;
            }
            case "deletar": {
                // ... 
                rolesDocument.delete(/* .. */) // [!code highlight]
                await rolesDocument.save() // [!code highlight]
                return;
            }
            // ...
          }
        return;
      }
      case "canais": {
        const channelsDocument = await db.channels.get(guild.id); // [!code ++]
        switch (subcommand) {
          case "criar": {
              // ... 
              channelsDocument.set(/* .. */) // [!code highlight]
              await channelsDocument.save() // [!code highlight]
              return;
          }
          case "deletar": {
              // ... 
              channelsDocument.delete(/* .. */) // [!code highlight]
              await channelsDocument.save() // [!code highlight]
              return;
          }
          // ...
        }
        return;
      }
    }
  }
});
```

Agora com a modulariza√ß√£o, se voc√™ precisar buscar alguma informa√ß√£o que ser√° usada em todos os sub comandos, para que voc√™ n√£o precise executar o mesmo c√≥digo em cada arquivo, basta usar o `run` do grupo e retornar os dados que voc√™ precisar:

```ts tab="Cargos" title="roles/group.ts"
import command from "../command.js";

export default command.group({
    name: "cargos",
    description: "Gerenciar cargos",
    async run({ guild }){
      const document = await db.roles.get(guild.id);
      return document; // [!code ++]
    }
});
```
```ts tab="Canais" title="channels/group.ts"
import command from "../command.js";

export default command.group({
    name: "canais",
    description: "Gerenciar canais",
    async run({ guild }){
      const document = await db.channels.get(guild.id);
      return document; // [!code ++]
    }
});
```

Ent√£o o segundo argumento do seu sub comando ser√° o retorno do `run` do grupo:

```ts tab="Cargos" title="roles/create.ts"
import group from "./group.js";
import { ApplicationCommandOptionType } from "discord.js";

export default group.subcommand({
    name: "criar",
    description: "Criar um novo cargo",
    options: [
      // ...
    ],
    // [!code word:document]
    async run(interaction, document){
      document // RolesDocument
      // ...
    }
});
```
```ts tab="Canais" title="channels/create.ts"
import group from "./group.js";
import { ApplicationCommandOptionType } from "discord.js";

export default group.subcommand({
    name: "criar",
    description: "Criar um novo canal",
    options: [
      // ...
    ],
    // [!code word:document]
    async run(interaction, document){
      document // ChannelsDocument
      // ...
    }
});
```

## Fluxo de execu√ß√£o

Desde a declara√ß√£o do comando at√© o sub comando, √© poss√≠vel executar c√≥digos entre eles e cada run recebe o retorno do anterior, com excess√£o do primeiro.

```ts
import { createCommand } from "#base";

const command = createCommand({
    name: "foo",
    async run(){
        console.log("Comando foo");
        return "foo";
    }
})

const group = command.group({
    name: "bar",
    async run(_, data){
        console.log("Grupo bar");
        console.log("Recebe", data); // "Recebe foo"
        return "bar";
    }
});

group.subcommand({
    name: "baz",
    async run(_, data) {
        console.log("Sub comando baz do grupo bar");
        console.log("Recebe", data); // "Recebe bar"
    },
});
```

O `run` do comando √© exeutado primeiro, ent√£o o retorno dele √© passado como segundo argumento para o grupo. O `run` do grupo √© executado e o seu retorno √© passado para o sub comando:

```json
Comando
 ‚îî‚îÄ "foo" ‚îÄ> Grupo
                ‚îî‚îÄ "bar" ‚îÄ> Sub command

``` 

<Callout type="warn">
  Ent√£o fique atento ao responder intera√ß√µes entre as fun√ß√µes `run`, pois se voc√™ responder a intera√ß√£o no `run` do comando e responder novamente no `run` do sub comando, voc√™ receber√° um erro do discord! 
</Callout>

Se voc√™ n√£o precisar de nenhuma execu√ß√£o al√©m da do sub comando, n√£o √© obrigat√≥rio definir fun√ß√µes `run` no comando e no grupo:

```ts
import { createCommand } from "#base";

const command = createCommand({
    name: "foo",
})

const group = command.group({
    name: "bar",
});

group.subcommand({
    name: "baz",
    async run(interaction) {
      await interaction.reply("Executando: /foo bar baz");
      // ...
    },
});
```

<Callout type="warn">
  Uma √∫ltima considera√ß√£o sobre o objeto que o `createCommand` retorna: Voc√™ pode definir tanto grupos, quanto sub comandos para o comando:
  
   ```ts
    import { createCommand } from "#base";
    // [!code word:command]

    const command = createCommand({
        name: "gerenciar",
    })

    const group = command.group({
        name: "canais",
        options: [
          {
            name: "criar",
            // ...
          },
          // ...
        ]
    });

    command.subcommand({
        name: "painel",
    });
    ```

    - /gerenciar canais criar
    - /gerenciar painel
</Callout>

# Planos futuros

Mais coisas est√£o sendo estudadas para serem implementadas aos comandos na base, este recurso √© s√≥ uma introdu√ß√£o e um preparo para as pr√≥ximas adi√ß√µes...

---

Novidades, atualiza√ß√µes, altera√ß√µes, dicas e muito mais ser√° postado neste blog! Se voc√™ quiser ser notificado sempre que uma nova postagem for publicada, entre no discord [Zunder Community](http://discord.gg/tTu8dGN) ou Siga [@rinckodev no twitter/x](https://x.com/rinckodev)